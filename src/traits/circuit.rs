use ff::{PrimeField, PrimeFieldBits};
use crate::traits::Group;

pub struct StepCircuit<F:PrimeField, CS: ConstraintSystem>{
    input: F,
    cs: CS,


}

/// Return the the number of inputs or outputs of each step
/// (this method is called only at circuit synthesis time)
/// `synthesize` and `output` methods are expected to take as
/// input a vector of size equal to arity and output a vector of size equal to arity
fn arity(&self) -> usize;

/// Sythesize the circuit for a computation step and return variable
/// that corresponds to the output of the step z_{i+1}
fn synthesize(&self);
// fn synthesize<CS: ConstraintSystem<F>>(
//     &self,
//     cs: &mut CS,
//     z: &[AllocatedNum<F>],
// ) -> Result<Vec<AllocatedNum<F>>, SynthesisError>;


trait SpecialSound{

    // r_0 = p_NARK(pi)
    fn r0();

    /// C_i = commit(ck, w_i)
    fn commit_witness();

    /// r_i = p_NARK(r_{i-1},C_i}
    fn ri();

    /// e = cal(constraint_poly, witness)
    /// 1. previous round error term is prev_e = [e_coff_1 * X, e_coff_2 * X^2, ... , e_coff_(d-1) * X^(d-1)]
    /// 2. current round generate current_e = [e_coff_1 * X, e_coff_2 * X^2, ... , e_coff_(d-1) * X^(d-1)]
    /// 3. e' = new_e = prev_e + current_e
    /// 4. commit(new_e)
    fn calculate_error_term();
    /// commit
    fn commit_error_term();
}


struct AccumulatorInstance<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize>{
    pi: [F;POLY_NUM],
    // witness (messages) commitment
    ci: [G;TOTAL_ROUND],
    // random challenge points for witness commitment
    ri: [F;TOTAL_ROUND-1],
    // accumulator of error term commitment
    error_term_commitments: [G;POLY_DEGREE-1],
    // error term
    error_terms: [[F;POLY_NUM];POLY_DEGREE-1],
    // slack variable
    slack_varible: F,
}

struct AccumulatorWitness<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize>{
    messages: [[F;POLY_DEGREE];TOTAL_ROUND],
}


// according to the definition of PROTOSTAR 3.3
struct NarkProof<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize>{
    // public
    ci: [G;TOTAL_ROUND],
    // private
    messages: [[F;POLY_DEGREE];TOTAL_ROUND],
}

impl<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize> NarkProof<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>{

}
struct AccumulationProver<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize>{
    cur_round: u64,
    // commitment key
    ck: [G;POLY_DEGREE],
    // accumulator instance
    acc_ins: AccumulatorInstance<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>,
    // accumulator witness
    acc_wit: AccumulatorWitness<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>,
    // === NARK PROOF ===
    nark_proof: NarkProof<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>,
    // determine Commitment Scheme for messages
    commit_func:fn(setup:[G;POLY_DEGREE], message: [F;POLY_DEGREE])->G,
}

struct AccumulationVerifier<F: PrimeField,G: Group, const TOTAL_ROUND:usize, const POLY_NUM:usize, const POLY_DEGREE:usize>{
    cur_round: u64,
    // accumulator instance
    acc_ins: AccumulatorInstance<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>,
    // updated accumulator instance
    updated_acc_ins: AccumulatorInstance<F,G,TOTAL_ROUND,POLY_NUM,POLY_DEGREE>,
    // accumulation proof generated by accumulation prover which is the commitment of Error Term Coefficients
    pf: [G;POLY_DEGREE-1],
    // NARK Proof Instance
    ci: [G;TOTAL_ROUND],
}

trait ErrorTermRecorder{

}